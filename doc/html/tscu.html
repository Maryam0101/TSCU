
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>tscu</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-06-14"><meta name="DC.source" content="tscu.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> out = tscu(x,y,varargin)
<span class="comment">%TSCU Time Series Classification Utility</span>
<span class="comment">%   TSCU(X) first divides the set X into training and testing sets</span>
<span class="comment">%   randomly, then classifies the time series in the testing set by using</span>
<span class="comment">%   the time series in the training set  with default classification</span>
<span class="comment">%   method (K-NN) and distance metric (Euclidean). The rows of X</span>
<span class="comment">%   corresponds to the time series. The first column defines the labels of</span>
<span class="comment">%   the time series.</span>
<span class="comment">%</span>
<span class="comment">%   TSCU(X,Y) classifies the time series in the testing set Y by using</span>
<span class="comment">%   the time series in the training set X with default classification</span>
<span class="comment">%   method (K-NN) and distance metric (Euclidean). The rows of both X and Y</span>
<span class="comment">%   corresponds to the time series in the training and testing sets,</span>
<span class="comment">%   respectively. The first column of both X and Y should be the labels of</span>
<span class="comment">%   the time series.</span>
<span class="comment">%</span>
<span class="comment">%   TSCU(X,Y,'option1',value1,'option2',value2,...) classifies</span>
<span class="comment">%   the time series in Y by using training set X by using the options.</span>
<span class="comment">%   Available options are:</span>
<span class="comment">%</span>
<span class="comment">%   'Classifier': The preferrred classification technique</span>
<span class="comment">%    'K-NN'   : K Nearest Neighbor</span>
<span class="comment">%    'SVM'    : Linear Support Vector Machines</span>
<span class="comment">%    default  : 'K-NN'</span>
<span class="comment">%</span>
<span class="comment">%   'Alignment': Alignment method</span>
<span class="comment">%    'NONE'   : no alignment</span>
<span class="comment">%    'DTW'    : Dynamic Time Warping</span>
<span class="comment">%    'CDTW'   : Constained Time Warping</span>
<span class="comment">%    'SAGA'   : Signal Alignment via Genetic Algorithm</span>
<span class="comment">%    'CREG'   : Curve Registration of Ramsay &amp; Silverman</span>
<span class="comment">%    default  : 'NONE'</span>
<span class="comment">%</span>
<span class="comment">%   'SVMKernel': Kernel type of SVM classifier</span>
<span class="comment">%    'linear'     : Linear</span>
<span class="comment">%    'gaussian'   : Gaussian</span>
<span class="comment">%    default      : 'linear'</span>
<span class="comment">%</span>
<span class="comment">%   'LogLevel': Log level</span>
<span class="comment">%    'Emergency'  : (level 0)</span>
<span class="comment">%    'Alert'      : (level 1)</span>
<span class="comment">%    'Critical'   : (level 2)</span>
<span class="comment">%    'Error'      : (level 3)</span>
<span class="comment">%    'Warning'    : (level 4)</span>
<span class="comment">%    'Notice'     : (level 5)</span>
<span class="comment">%    'Info'       : (level 6)</span>
<span class="comment">%    'Debug'      : (level 7)</span>
<span class="comment">%    default      : 'Info'</span>
<span class="comment">%</span>
<span class="comment">%   'SAGAOptimizationMethod': Optimization technique used in SAGA</span>
<span class="comment">%    'GA'         : Genetic Algorithm</span>
<span class="comment">%    'GA_MEX'     : A simplified MEX version of Genetic Algorithm</span>
<span class="comment">%    'Simplex'    : Nelder-Mead Simplex method (fminsearch of MATLAB)</span>
<span class="comment">%    default      : 'GA_MEX'</span>
<span class="comment">%</span>
<span class="comment">%   'SAGABaseLength': The number of B-spline bases in ODE</span>
<span class="comment">%    default      : 8</span>
<span class="comment">%</span>
<span class="comment">%   'SAGAInitialSolution': Initial solution in SAGA</span>
<span class="comment">%    default      : zero vector with length SAGABaseLength.</span>
<span class="comment">%</span>
<span class="comment">%   'CrossValidation': An integer specifying how many time the</span>
<span class="comment">%    cross validation takes place.</span>
<span class="comment">%    default      : 0 means don't do cross validation</span>
<span class="comment">%</span>
<span class="comment">%   'MATLABPool': MATLAB pool used for parallel computing</span>
<span class="comment">%    'local' : Set it it 'local' if you want to use the processors</span>
<span class="comment">%              available in local PC.</span>
<span class="comment">%    default : '' no pool for parallel computing.</span>
<span class="comment">%</span>
<span class="comment">%   'reportLineWidth': Line width of report lines. Actually it defines</span>
<span class="comment">%    the width of the first part of the lines.</span>
<span class="comment">%    default : 60</span>
<span class="comment">%</span>
<span class="comment">%   'trainingRatio': Ratios of training set to the whole set of training</span>
<span class="comment">%    and testing. Defined between 0 and 1.</span>
<span class="comment">%    default : 0.30</span>
<span class="comment">%</span>
<span class="comment">%   'DTWbandwidth': It is the width of the Sakoe-Chiba band defined in</span>
<span class="comment">%    percentage. Setting it to 100 is the same effect as running DTW.</span>
<span class="comment">%    default: 6</span>
<span class="comment">%</span>
<span class="comment">%   'DisplayInputData': Display both training and testing data</span>
<span class="comment">%    'yes'          : plot the input data</span>
<span class="comment">%    'no'           : don't display!</span>
<span class="comment">%    default : 'no'</span>
<span class="comment">%</span>
<span class="comment">%   'DisplayAlignment': Display alignment for the specified instances</span>
<span class="comment">%    defined as {trnidx, tstidx}</span>
<span class="comment">%    default : {[],[]} (means no alignment is displayed)</span>
<span class="comment">%    example : tscu(trn,tst,'DisplayAlignment',{[1 3],[1]}) will display the</span>
<span class="comment">%    alignment of test sample 1 to the training samples 1 and 3, so</span>
<span class="comment">%    two alignments will be displayed.</span>
<span class="comment">%</span>
<span class="comment">%    The figures will be saved in PDF on the current directory.</span>
<span class="comment">%</span>
<span class="comment">%   'DumpDistanceMatrix': Dump the distance matrix ta a txt file.</span>
<span class="comment">%    'yes' : dump it</span>
<span class="comment">%    'no'  : don't!</span>
<span class="comment">%    default : 'no'</span>
<span class="comment">%</span>
<span class="comment">%   Z = TSCU(...) returns output values in the structure Z.</span>
<span class="comment">%</span>

<span class="comment">% I'm adding this small library of Oliver Woodford to produce PDFs</span>
<span class="comment">% ready for publication It's license allows me to include it.</span>
<span class="comment">% See lib/export_fig/license.txt</span>
addpath(<span class="string">'lib/export_fig'</span>);
addpath(<span class="string">'lib/creg'</span>);

options = getDefaultOptions;
<span class="keyword">if</span> nargin == 0
    error(<span class="string">'tscu:noinput'</span>,<span class="string">'Not enough input arguments.'</span>);
<span class="keyword">elseif</span> nargin == 1
    [x,y]=divideset(x,options);
    displine(<span class="string">'Info'</span>,<span class="string">'Size of input set'</span>,sprintf(<span class="string">'%d'</span>,size(x,1)),options);
    displine(<span class="string">'Info'</span>,<span class="string">'Dividing input into trn/tst'</span>,<span class="string">'done'</span>,options);
<span class="keyword">elseif</span> nargin == 2,
    <span class="keyword">if</span> size(x,2) ~= size(y,2)
        error(<span class="string">'tscu:invalidlength'</span>,<span class="keyword">...</span>
            <span class="string">'Length of time series in training and testing sets should be equal'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>

optarglength = size(varargin,2);
<span class="keyword">if</span> mod(optarglength,2) ~= 0
    error(<span class="string">'tscu:argerror'</span>,<span class="string">'The number of optional parameters should be even'</span>);
<span class="keyword">else</span>
    <span class="keyword">for</span> i=1:2:optarglength
        <span class="keyword">switch</span> varargin{i}
            <span class="keyword">case</span> <span class="string">'Classifier'</span>
                options.classifier = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'Alignment'</span>
                options.alignment = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'SVMKernel'</span>
                options.svmkernel = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'DTWbandwidth'</span>
                options.DTWbandwidth = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'LogLevel'</span>
                options.loglevel = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'MATLABPool'</span>
                options.MATLABPool = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'SAGAOptimizationMethod'</span>
                options.SAGAOptimizationMethod = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'SAGABaseLength'</span>
                options.SAGABaseLength = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'SAGAInitialSolution'</span>
                options.SAGAInitialSolution = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'CrossValidation'</span>
                options.CrossValidation = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'DisplayInputData'</span>
                options.DisplayInputData = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'DisplayAlignment'</span>
                options.DisplayAlignment = varargin{i+1};
            <span class="keyword">case</span> <span class="string">'DumpDistanceMatrix'</span>
                options.DumpDistanceMatrix = varargin{i+1};
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Opening MATLAB pool</span>
<span class="keyword">if</span> ~isempty(options.MATLABPool)
    displine(<span class="string">'Info'</span>,<span class="string">'Setting parallel processing'</span>,<span class="string">''</span>,options);
    matlabpool(<span class="string">'open'</span>,options.MATLABPool);
<span class="keyword">end</span>

<span class="keyword">if</span> options.SAGABaseLength ~= length(options.SAGAInitialSolution)
    displine(<span class="string">'Warning'</span>,<span class="string">'Size of initial solution should be'</span>,<span class="keyword">...</span>
        sprintf(<span class="string">'%d'</span>,length(options.SAGABaseLength)),options);
<span class="keyword">end</span>

<span class="comment">% Check the optimization method</span>
<span class="keyword">switch</span> options.SAGAOptimizationMethod
    <span class="keyword">case</span> <span class="string">'GA'</span>
    <span class="keyword">case</span> <span class="string">'Simplex'</span>
    <span class="keyword">case</span> <span class="string">'GA_MEX'</span>
    <span class="keyword">otherwise</span>
        displine(<span class="string">'Warning'</span>,sprintf(<span class="string">'The method "%s" is not recognized'</span>,<span class="keyword">...</span>
            options.SAGAOptimizationMethod),<span class="string">'GA_MEX will be used'</span>,options);
        options.SAGAOptimizationMethod = <span class="string">'GA_MEX'</span>;
<span class="keyword">end</span>

<span class="keyword">switch</span> options.alignment
    <span class="keyword">case</span> <span class="string">'NONE'</span>
        options.alignmentfunction = @nonealignment;
    <span class="keyword">case</span> <span class="string">'DTW'</span>
        options.alignmentfunction = @dtwalignment;
    <span class="keyword">case</span> <span class="string">'CDTW'</span>
        options.alignmentfunction = @cdtwalignment;
    <span class="keyword">case</span> <span class="string">'SAGA'</span>
        options.alignmentfunction = @sagaalignment;
        n = size(x,2)-1;
        k = options.SAGABaseLength;
        options.SAGAz = zeros(1,n);
        options.SAGAw = zeros(1,n);
        options.SAGAs = zeros(1,k);
        options.SAGAsbest = zeros(1,k);
        u = zeros(n,k);
        nk = round(n/k);
        lastpiece = n-nk*k;
        <span class="keyword">for</span> i=0:k-2
            u(nk*i+1:nk*i+nk,i+1)=1;
        <span class="keyword">end</span>
        u(n-lastpiece-1:n,k)=1;
        integration    = @(s) cumsum(s)/(size(s,1)-1);
        options.SAGAbmat = integration(integration(u));
    <span class="keyword">case</span> <span class="string">'CREG'</span>
        options.alignmentfunction = @cregalignment;
    <span class="keyword">otherwise</span>
        options.alignmentfunction = @nonealignment;
<span class="keyword">end</span>

<span class="comment">% Display some debug</span>
displine(<span class="string">'Info'</span>,<span class="string">'Size of training set'</span>,sprintf(<span class="string">'%d'</span>,size(x,1)),options);
displine(<span class="string">'Info'</span>,<span class="string">'Size of testing set'</span>,sprintf(<span class="string">'%d'</span>,size(y,1)),options);
displine(<span class="string">'Info'</span>,<span class="string">'Time series length'</span>,sprintf(<span class="string">'%d'</span>,size(x,2)-1),options);

displine(<span class="string">'Info'</span>,<span class="string">'Classification method'</span>,options.classifier,options);
<span class="keyword">if</span> strcmp(options.classifier,<span class="string">'SVM'</span>)
    displine(<span class="string">'Info'</span>,<span class="string">'SVM kernel type'</span>,options.svmkernel,options);
<span class="keyword">end</span>
displine(<span class="string">'Info'</span>,<span class="string">'Alignment method'</span>,options.alignment,options);
displine(<span class="string">'Info'</span>,<span class="string">'Displaying input data'</span>,options.DisplayInputData,options);

<span class="keyword">if</span> options.CrossValidation &lt; 1
    displine(<span class="string">'Info'</span>,<span class="string">'No cross validation is chosen'</span>,<span class="keyword">...</span>
        sprintf(<span class="string">'%d'</span>,options.CrossValidation),options);
<span class="keyword">else</span>
    displine(<span class="string">'Info'</span>,<span class="string">'Cross validation is not implemented'</span>,<span class="keyword">...</span>
        sprintf(<span class="string">'%d'</span>,options.CrossValidation),options);
<span class="keyword">end</span>
<span class="keyword">if</span> strcmp(options.alignment,<span class="string">'SAGA'</span>)
    displine(<span class="string">'Info'</span>,<span class="string">'SAGA number of spline bases'</span>,<span class="keyword">...</span>
        sprintf(<span class="string">'%d'</span>,options.SAGABaseLength),options);
    displine(<span class="string">'Info'</span>,<span class="string">'SAGA optimization method'</span>,<span class="keyword">...</span>
        options.SAGAOptimizationMethod,options);
    displine(<span class="string">'Info'</span>,<span class="string">'SAGA initial solution'</span>,<span class="keyword">...</span>
        sprintf(<span class="string">'%5.2f '</span>,options.SAGAInitialSolution),options);
<span class="keyword">end</span>
<span class="keyword">if</span> strcmp(options.alignment,<span class="string">'CDTW'</span>)
    displine(<span class="string">'Info'</span>,<span class="string">'DTW band width (%)'</span>,<span class="keyword">...</span>
        sprintf(<span class="string">'%5.2f'</span>,options.DTWbandwidth),options);
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(options.MATLABPool)
    displine(<span class="string">'Info'</span>,<span class="string">'MATLAB Pool'</span>,options.MATLABPool,options);
<span class="keyword">end</span>

<span class="keyword">if</span> numel(options.DisplayAlignment{1}) &gt; 0 &amp;&amp; numel(options.DisplayAlignment{2}) &gt; 0
    displine(<span class="string">'Info'</span>,<span class="string">'Displaying alignments (trn)'</span>,<span class="keyword">...</span>
        sprintf(<span class="string">'%d'</span>,options.DisplayAlignment{1}),options);
    displine(<span class="string">'Info'</span>,<span class="string">'Displaying alignments (tst)'</span>,<span class="keyword">...</span>
        sprintf(<span class="string">'%d'</span>,options.DisplayAlignment{2}),options);
<span class="keyword">else</span>
    displine(<span class="string">'Info'</span>,<span class="string">'Displaying alignments'</span>,<span class="string">'none'</span>,options);
<span class="keyword">end</span>
displine(<span class="string">'Info'</span>,<span class="string">'Dumping distance matrix'</span>,options.DumpDistanceMatrix,options);


<span class="comment">% Displaying Input Data</span>
<span class="keyword">if</span> strcmp(options.DisplayInputData,<span class="string">'yes'</span>)
    displayInputData(x,y,options);
<span class="keyword">end</span>
displayClassInfo(x,y,options);


<span class="comment">% Classification</span>
tic
<span class="keyword">switch</span> options.classifier
    <span class="keyword">case</span> <span class="string">'K-NN'</span>
        labels = nnclassifier(x,y,options);
    <span class="keyword">case</span> <span class="string">'SVM'</span>
        labels = svmclassifier(x,y,options);
    <span class="keyword">otherwise</span>
        labels = nnclassifier(x,y,options);
<span class="keyword">end</span>
classification_time = toc;

<span class="comment">% Performance</span>
perf = performance(y(:,1),labels);
displine(<span class="string">'Info'</span>,<span class="string">'Overall Accuracy'</span>,sprintf(<span class="string">'%-8.3f'</span>,perf.OA),options);
displine(<span class="string">'Info'</span>,<span class="string">'Overall Error'</span>,sprintf(<span class="string">'%-8.3f'</span>,perf.error),options);
displine(<span class="string">'Info'</span>,<span class="string">'Producer Accuracy'</span>,sprintf(<span class="string">'%-8.3f'</span>,perf.PA),options);
displine(<span class="string">'Info'</span>,<span class="string">'User Accuracy'</span>,sprintf(<span class="string">'%-8.3f'</span>,perf.UA),options);
displine(<span class="string">'Info'</span>,<span class="string">'Kappa'</span>,sprintf(<span class="string">'%-8.3f'</span>,perf.kappa),options);
displine(<span class="string">'Info'</span>,<span class="string">'Z-value'</span>,sprintf(<span class="string">'%-8.3f'</span>,perf.Z),options);
displine(<span class="string">'Info'</span>,<span class="string">'Confusion matrix'</span>,sprintf(<span class="string">'\n%s'</span>,perf.confmatdisplay),options);
displine(<span class="string">'Info'</span>,<span class="string">'Classification time (sec)'</span>,<span class="keyword">...</span>
    sprintf(<span class="string">'%-8.2f'</span>,classification_time),options);

<span class="comment">% Closing the MATLAB pool if paralel process</span>
<span class="keyword">if</span> ~isempty(options.MATLABPool)
    displine(<span class="string">'Info'</span>,<span class="string">'Setting parallel processing'</span>,<span class="string">''</span>,options);
    matlabpool <span class="string">close</span>
<span class="keyword">end</span>

<span class="comment">% Returning output</span>
out.labels              = labels;
out.truelabels          = y(:,1);
out.classification_time = classification_time;
out.perf                = perf;
displine(<span class="string">'Info'</span>,<span class="string">'The end of TSCU'</span>,<span class="string">'FINISHED'</span>,options);
<span class="keyword">end</span>

<span class="keyword">function</span> displayClassInfo(x,y,options)
<span class="comment">% Display class information</span>

uniquelabels=unique([x(:,1);y(:,1)]);
<span class="comment">% For each class</span>
<span class="keyword">for</span> i=1:length(uniquelabels)
    trnidx = uniquelabels(i)==x(:,1);
    tstidx = uniquelabels(i)==y(:,1);
    displine(<span class="string">'Info'</span>,<span class="string">'Class information'</span>,<span class="keyword">...</span>
        sprintf(<span class="string">'%d [TRN:%3d TST:%3d]'</span>,uniquelabels(i),sum(trnidx),sum(tstidx)),options);

<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> displayInputData(x,y,options)
<span class="comment">% Display training and testing sets.</span>

uniquelabels=unique([x(:,1);y(:,1)]);
<span class="comment">% For each class</span>
<span class="keyword">for</span> i=1:length(uniquelabels)
    trnidx = uniquelabels(i)==x(:,1);
    tstidx = uniquelabels(i)==y(:,1);


    figure
    subplot(211);
    plot(x(trnidx,2:end)',<span class="string">'k'</span>);
    title(sprintf(<span class="string">'%d time series in training set of class label %d'</span>,<span class="keyword">...</span>
        sum(trnidx),uniquelabels(i)));
    subplot(212);
    plot(y(tstidx,2:end)',<span class="string">'k'</span>);
    title(sprintf(<span class="string">'%d time series in testing set of class label %d'</span>,<span class="keyword">...</span>
        sum(tstidx),uniquelabels(i)));
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> options = getDefaultOptions(varargin)
<span class="comment">% Please see help tscu for available options.</span>

options.classifier               = <span class="string">'K-NN'</span>;
options.alignment                = <span class="string">'NONE'</span>;
options.loglevel                 = <span class="string">'Info'</span>;
options.svmkernel                = <span class="string">'linear'</span>;
options.reportLineWidth          = 40;
options.trainingRatio            = 0.3;
options.DTWbandwidth             = 6;
options.MATLABPool               = <span class="string">''</span>;
options.SAGAOptimizationMethod  = <span class="string">'GA_MEX'</span>;
options.SAGABaseLength          = 8;
options.SAGAInitialSolution     = zeros(1,options.SAGABaseLength);
options.DisplayInputData        = <span class="string">'no'</span>;
options.CrossValidation         = 0;
options.DisplayAlignment        = {[],[]};
options.DumpDistanceMatrix      = <span class="string">'no'</span>;
options.alignmentfunction       = @nonealignment;
<span class="keyword">if</span> nargin &gt; 0 &amp;&amp; mod(nargin,2) ~= 0
    error(<span class="string">'tscu:invalidoption'</span>,<span class="string">'The number of input variables must be even'</span>);
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> displine(l,k,v,o)
<span class="comment">%DISPLINE Display a report line</span>
<span class="comment">%   DISPLINE(L,K,V,O) display the string K with value V by using</span>
<span class="comment">%   the parameters in O if current loglevel is less than or equal to</span>
<span class="comment">%   logvel K. For example, DISPLINE('Info','Length',12,options)</span>
<span class="comment">%   will display</span>
<span class="comment">%   Length.......................: 12</span>
<span class="comment">%   if the current log level option is 'Info' or 'Debug'.</span>
<span class="comment">%   See options.loglevel setting.</span>

<span class="keyword">if</span> getloglevelindex(l) &lt;= getloglevelindex(o.loglevel)
    out=sprintf(<span class="string">'%s'</span>,k);
    <span class="keyword">for</span> i=length(k):o.reportLineWidth
        out=sprintf(<span class="string">'%s.'</span>,out);
    <span class="keyword">end</span>
    out=sprintf(<span class="string">'%s: %s'</span>,out,v);
    fprintf(<span class="string">'%s\n'</span>,out)
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> i = getloglevelindex(l)
<span class="comment">%GETLOGLEVELINDEX  Conversion of log level string.</span>
<span class="comment">%   GETLOGLEVELINDEX(L) gets the corresponding integer for a given</span>
<span class="comment">%   log level L.</span>
<span class="keyword">switch</span> l
    <span class="keyword">case</span> <span class="string">'Emergency'</span>
        i = 0;
    <span class="keyword">case</span> <span class="string">'Alert'</span>
        i = 1;
    <span class="keyword">case</span> <span class="string">'Critical'</span>
        i = 2;
    <span class="keyword">case</span> <span class="string">'Error'</span>
        i = 3;
    <span class="keyword">case</span> <span class="string">'Warning'</span>
        i = 4;
    <span class="keyword">case</span> <span class="string">'Notice'</span>
        i = 5;
    <span class="keyword">case</span> <span class="string">'Info'</span>
        i = 6;
    <span class="keyword">case</span> <span class="string">'Debug'</span>
        i = 7;
    <span class="keyword">otherwise</span>
        i = 6;
<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">function</span> [trn,tst]=divideset(x,options)
<span class="comment">%DIVIDESET Divides a set of time series into two parts.</span>
<span class="comment">%   DIVIDESET(X,OPTIONS) divides the dataset X into training (X) and testing</span>
<span class="comment">%   sets (Y) by using the ratios OPTIONS.trainingRatio.</span>
<span class="comment">%</span>
<span class="comment">%</span>
m=size(x,1);
labels = x(:,1);

<span class="comment">% index of which objects will be reserved for training.</span>
trnidx = zeros(m,1);
<span class="comment">% If a label is not an integer, exit with error.</span>
floatlabels=find(abs(round(labels)-labels)&gt;eps);
<span class="keyword">if</span> numel(floatlabels) &gt; 0
    error(<span class="string">'tscu:floatinglabels'</span>,<span class="keyword">...</span>
        <span class="string">'Some labels are not integer. Example: label of object [%d] is %f'</span>,floatlabels(1),x(floatlabels(1),1));
<span class="keyword">end</span>
uniquelabels = unique(labels);
<span class="keyword">for</span> i=1:length(uniquelabels)
    label=uniquelabels(i);
    labelidx = find(label==labels);

    trnlength = round(length(labelidx)*options.trainingRatio);

    <span class="keyword">if</span> trnlength &lt; 1
        warning(<span class="string">'tscu:divideset'</span>,<span class="string">'There is no object left to training set for label %d'</span>,label);
        trnlength = 0;
    <span class="keyword">end</span>
    trnidx(labelidx(1:trnlength))=1;
<span class="keyword">end</span>
trn = x(trnidx==1,:);
tst = x(trnidx==0,:);
<span class="keyword">end</span>

<span class="keyword">function</span> labels = nnclassifier(x,y,options)
<span class="comment">%NNCLASSIFIER Nearest Neighbor Classification</span>
<span class="comment">%   LABELS = NNCLASSIFIER(X,Y,OPTIONS) classifies the time series in</span>
<span class="comment">%   testing set Y by using the time series in training set X with the</span>
<span class="comment">%   nearest neighbor algorithm resulting estimated labels LABELS.</span>
xlabels = x(:,1);
ylabels = y(:,1);
n = size(x,1); <span class="comment">% training</span>
m = size(y,1); <span class="comment">% testing</span>
[yIdx,xIdx] = meshgrid(1:m,1:n);
alldistances = zeros(1,n*m);

Alignment = options.alignment;
DisplayAlignmentMat = zeros(n,m);
DisplayAlignmentMat(options.DisplayAlignment{1},options.DisplayAlignment{2})=1;

<span class="comment">% It may seem awkward not to use two inner loops for a simple</span>
<span class="comment">% K-NN classifier. The reason is that I should use just one loop</span>
<span class="comment">% to easily distribute the job.</span>
<span class="keyword">for</span> i = 1 : n*m
    yObject = y(yIdx(i),2:end);
    xObject = x(xIdx(i),2:end);
    path1 = 1:numel(xObject);
    path2 = 1:numel(yObject);
    <span class="keyword">switch</span> Alignment
        <span class="keyword">case</span> <span class="string">'NONE'</span>
            [alldistances(i), path1, path2] = nonealignment(xObject,yObject,options);
        <span class="keyword">case</span> <span class="string">'DTW'</span>
            [alldistances(i), path1, path2] = dtwalignment(xObject,yObject,options);
        <span class="keyword">case</span> <span class="string">'CDTW'</span>
            [alldistances(i), path1, path2] = cdtwalignment(xObject,yObject,options);
        <span class="keyword">case</span> <span class="string">'SAGA'</span>
            [alldistances(i), path1, path2] = sagaalignment(xObject,yObject,options);
        <span class="keyword">case</span> <span class="string">'CREG'</span>
            [alldistances(i), path1, path2] = cregalignment(xObject,yObject,options);
        <span class="keyword">otherwise</span>
            [alldistances(i), path1, path2] = nonealignment(xObject,yObject,options);
    <span class="keyword">end</span>
    displine(<span class="string">'Debug'</span>,sprintf(<span class="string">'[%5d of %5d] dist(%4d,%4d)'</span>,i,n*m,yIdx(i),xIdx(i)),<span class="keyword">...</span>
        sprintf(<span class="string">'%f'</span>,alldistances(i)),options);
    <span class="keyword">if</span> DisplayAlignmentMat(i)
        displayAlignment(x,y,xIdx(i),yIdx(i),path1,path2,Alignment,options)
    <span class="keyword">end</span>
<span class="keyword">end</span>
distancematrix = reshape(alldistances,n,m);
[~,mindistanceIdx]=min(distancematrix);
labels = xlabels(mindistanceIdx);
displine(<span class="string">'Debug'</span>,<span class="string">'index of testing objects'</span>,sprintf(<span class="string">'%3d '</span>,1:m),options);
displine(<span class="string">'Debug'</span>,<span class="string">'labels of testing objects (True)'</span>,sprintf(<span class="string">'%3d '</span>,ylabels),options);
displine(<span class="string">'Debug'</span>,<span class="string">'labels of testing objects (Estimated)'</span>,sprintf(<span class="string">'%3d '</span>,labels),options);
displine(<span class="string">'Debug'</span>,<span class="string">'closest training objects'</span>,sprintf(<span class="string">'%3d '</span>,mindistanceIdx),options);

<span class="keyword">if</span> strcmp(options.DumpDistanceMatrix,<span class="string">'yes'</span>)
    save(sprintf(<span class="string">'tscu_distancematrix_%s.txt'</span>,Alignment),<span class="string">'distancematrix'</span>,<span class="string">'-ascii'</span>);
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> labels = svmclassifier(x,y,options)
<span class="comment">%SVMCLASSIFIER Support Vector Machine Classification</span>
<span class="comment">%   LABELS = SVMCLASSIFIER(X,Y,OPTIONS)</span>

classlabels=unique(sort(x(:,1)));
m=length(classlabels);
tstlabels=zeros(size(y,1),(m-1)*m/2);

opt=optimset(<span class="string">'maxiter'</span>,500,<span class="string">'largescale'</span>,<span class="string">'off'</span>,<span class="string">'display'</span>,<span class="string">'off'</span>);
<span class="comment">% One against one approach</span>
k=1;
<span class="keyword">for</span> i=1:m-1
    <span class="keyword">for</span> j=i+1:m
        <span class="comment">% Training</span>
        class_one=x(x(:,1)==classlabels(i),2:end);
        class_two=x(x(:,1)==classlabels(j),2:end);
        objects=[class_one;class_two];
        truelabels=[-ones(size(class_one,1),1);ones(size(class_two,1),1)];
        displine(<span class="string">'Debug'</span>,<span class="string">'SVM one-against-one'</span>,<span class="keyword">...</span>
            sprintf(<span class="string">'class %2d .vs. class %2d'</span>,classlabels(i),classlabels(j)),options);
        nx=size(objects,1);
        xlen=size(objects,2);
        R=zeros(nx,nx);
        e=1e-6;
        C=10;                               <span class="comment">%Functional Trade-off</span>


        <span class="keyword">switch</span> options.svmkernel
            <span class="keyword">case</span> <span class="string">'linear'</span>
                <span class="keyword">if</span> strcmp(options.alignment,<span class="string">'NONE'</span>)
                    R=objects*objects';
                <span class="keyword">else</span>
                    <span class="keyword">for</span> ii=1:nx-1
                        <span class="keyword">for</span> jj=ii+1:nx
                            [distance, path1, path2]=options.alignmentfunction(objects(ii,:),objects(jj,:),options);
                            xAligned = interp1(1:xlen,objects(ii,:),path1);
                            yAligned = interp1(1:xlen,objects(jj,:),path2);
                            displine(<span class="string">'Debug'</span>,<span class="string">'Aligning'</span>,sprintf(<span class="string">'%5d .vs. %5d'</span>,ii,jj),options);
                            R(ii,jj)=xAligned*yAligned';
                            R(jj,ii)=R(ii,jj);
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                    <span class="keyword">for</span> ii=1:nx
                        R(ii,ii)=objects(ii,:)*objects(ii,:)';
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">case</span> <span class="string">'gaussian'</span>
                sigma=1;       <span class="comment">% Parameter of the kernel</span>
                D=buffer(sum([kron(objects,ones(nx,1))<span class="keyword">...</span>
                  - kron(ones(1,nx),objects')'].^2,2),nx,0);
                R=exp(-D/(2*sigma)); <span class="comment">% Kernel Matrix</span>
        <span class="keyword">end</span>

        Y=diag(truelabels);
        H=Y*R*Y+1e-6*eye(length(truelabels));         <span class="comment">%Matrix H regularized</span>
        f=-ones(size(truelabels)); a=truelabels'; K=0;
        Kl=zeros(size(truelabels));
        Ku=C*ones(size(truelabels));
        alpha=quadprog(H,f,[],[],a,K,Kl,Ku,[],opt); <span class="comment">%Solver</span>

        <span class="keyword">switch</span> options.svmkernel
            <span class="keyword">case</span> <span class="string">'linear'</span>
                w=objects'*(alpha.*truelabels);
                <span class="comment">%ind=find(alpha&gt;e &amp; alpha&lt;=C-e);</span>
                ind=find(alpha&lt;C);
                b=mean(truelabels(ind) - objects(ind,:)*w);
                <span class="comment">% Testing</span>
                tstvalues=y(:,2:end)*w+b;

                <span class="comment">%figure</span>
                <span class="comment">%subplot(121)</span>
                <span class="comment">%plot(alpha,'.');</span>
                <span class="comment">%title(sprintf('%d %d',i,j));</span>
                <span class="comment">%subplot(122);</span>
                <span class="comment">%plot(eig(H),'.');</span>


            <span class="keyword">case</span> <span class="string">'gaussian'</span>
                ind=find(alpha&gt;e);
                x_sv=objects(ind,:);    <span class="comment">% Extraction of the</span>
                                         <span class="comment">% support vectors</span>
                N_SV=length(ind);
                ind=find(alpha&gt;e &amp; alpha&lt;C-e);
                N_margin=length(ind);
                D=buffer(sum([kron(x_sv,ones(N_margin,1))<span class="keyword">...</span>
                 - kron(ones(1,N_SV),objects(ind,:)')'].^2,2),N_margin,0);
                R_margin=exp(-D/(2*sigma));
                y_margin=R_margin*(truelabels(ind).*alpha(ind));
                b=mean(truelabels(ind) - y_margin);

                N_test=size(y,1);
                D=buffer(sum([kron(x_sv,ones(N_test,1))<span class="keyword">...</span>
                 - kron(ones(1,N_SV),y(:,2:end)')'].^2,2),N_test,0);
                R_test=exp(-D/(2*sigma));
                tstvalues=R_test*(truelabels(ind).*alpha(ind))+b;
        <span class="keyword">end</span>
        tstlabels(tstvalues&lt; 0,k)=classlabels(i);
        tstlabels(tstvalues&gt;=0,k)=classlabels(j);
        k = k + 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
labels=mode(tstlabels,2);

displine(<span class="string">'Info'</span>,<span class="string">'index of testing objects'</span>,sprintf(<span class="string">'%3d '</span>,1:size(y,1)),options);
displine(<span class="string">'Info'</span>,<span class="string">'labels of testing objects (True)'</span>,sprintf(<span class="string">'%3d '</span>,y(:,1)),options);
displine(<span class="string">'Info'</span>,<span class="string">'labels of testing objects (Estimated)'</span>,sprintf(<span class="string">'%3d '</span>,labels),options);
<span class="comment">%displine('Info','closest training objects',sprintf('%3d ',mindistanceIdx),options);</span>

<span class="keyword">end</span>

<span class="keyword">function</span>  displayAlignment(x,y,xIdx,yIdx,path1,path2,Alignment,options)
<span class="comment">%DISPLAYALIGNMENT Displays the aligned time series</span>
<span class="comment">%   DISPLAYALIGNMENT(x,y,xIdx,yIdx,path1,path2,Alignment,options) will</span>
<span class="comment">%   display the alignment between the time series x(xIdx,2:end))</span>
<span class="comment">%   and y(yIdx,2:end)) by using the determined warpings path1 and path2</span>
<span class="comment">%   found by the alignment method Alignment.</span>
xObject = x(xIdx,2:end);
yObject = y(yIdx,2:end);
xAligned = interp1(1:length(xObject),xObject,path1);
yAligned = interp1(1:length(yObject),yObject,path2);

nx = numel(xObject);
xmin = min(xObject);
xmax = max(xObject);

ny = numel(yObject);
ymin = min(yObject);
ymax = max(yObject);

dx = 10;
<span class="keyword">if</span> nx &lt; 30
    dx = nx;
<span class="keyword">end</span>
xgrid=round(linspace(1,nx,dx));
ygrid=round(linspace(1,ny,dx));

relErrBefore = norm(xObject - yObject)/norm(xObject);
relErrAfter  = norm(xAligned - yAligned)/norm(xAligned);

figure(<span class="string">'Visible'</span>,<span class="string">'on'</span>);
plot(xObject,<span class="string">'b'</span>);
hold <span class="string">on</span>;
plot(yObject,<span class="string">'r'</span>);
legend(<span class="string">'Training'</span>,<span class="string">'Testing'</span>);
title(sprintf(<span class="string">'Originals Distance: %8.5f'</span>,relErrBefore));
xlim([1 max([nx ny])]);
<span class="comment">%export_fig('-pdf','-transparent',...</span>
<span class="comment">%    sprintf('tscu_alignment_%03d_%03d_%s_before.pdf',xIdx,yIdx,Alignment));</span>

figure(<span class="string">'Visible'</span>,<span class="string">'on'</span>);
plot(xAligned,<span class="string">'b'</span>);
hold <span class="string">on</span>;
plot(yAligned,<span class="string">'r'</span>);
legend(<span class="string">'Training'</span>,<span class="string">'Testing'</span>);
title(sprintf(<span class="string">'Alignment (%s) Distance: %8.5f'</span>,Alignment,relErrAfter));
xlim([1 length(xAligned)]);
<span class="comment">%export_fig('-pdf','-transparent',...</span>
<span class="comment">%    sprintf('tscu_alignment_%03d_%03d_%s_after.pdf',xIdx,yIdx,Alignment));</span>

<span class="comment">% warping is scaled to [0 1]</span>
figure(<span class="string">'Visible'</span>,<span class="string">'on'</span>);
<span class="comment">%plot((path1-1)/(length(path1)-1),(path2-1)/(length(path2)-1),'b');</span>
plot(path1,path2,<span class="string">'b'</span>);
hold <span class="string">on</span>
plot(nx*0.20*((xObject-xmin)/(xmax-xmin)-1),<span class="string">'r'</span>);
plot(ny*0.20*((yObject-ymin)/(ymax-ymin)-1),1:ny,<span class="string">'r'</span>);
set(gca,<span class="string">'XTick'</span>,[],<span class="string">'YTick'</span>,[])
box <span class="string">on</span>
plot(xgrid,meshgrid(xgrid,ygrid),<span class="string">'k:'</span>);
plot(meshgrid(xgrid,ygrid),ygrid,<span class="string">'k:'</span>);

<span class="keyword">if</span> strcmp(Alignment,<span class="string">'CDTW'</span>)
    band=floor(options.DTWbandwidth*nx/100);
    plot([1 1    nx-band nx],[1 band ny      ny],<span class="string">'k'</span>);
    plot([1 band nx      nx],[1 1    ny-band ny],<span class="string">'k'</span>);
<span class="keyword">end</span>

axis <span class="string">equal</span>
xlim([-nx*0.20 nx+1]);
ylim([-ny*0.20 ny+1]);
<span class="comment">%export_fig('-pdf','-transparent',...</span>
<span class="comment">%    sprintf('tscu_alignment_%03d_%03d_%s_warping.pdf',xIdx,yIdx,Alignment));</span>

figure(<span class="string">'Visible'</span>,<span class="string">'on'</span>);
<span class="keyword">for</span> i=round(linspace(1,length(path1),50))
    plot([path1(i) path2(i)], <span class="keyword">...</span>
        [interp1(1:nx,xObject,path1(i)) interp1(1:ny,yObject,path2(i))+2*xmax],<span class="string">'k'</span>);
    hold <span class="string">on</span>
<span class="keyword">end</span>
plot(xObject,<span class="string">'b'</span>);
plot(2*xmax+yObject',<span class="string">'b'</span>);
xlim([0 nx]);
set(gca,<span class="string">'XTick'</span>,[],<span class="string">'YTick'</span>,[])
box <span class="string">on</span>
<span class="comment">%export_fig('-pdf','-transparent',...</span>
<span class="comment">%    sprintf('tscu_alignment_%03d_%03d_%s_warpingLines.pdf',xIdx,yIdx,Alignment));</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [distance, path1, path2] = nonealignment(x,y,options)
<span class="comment">%NONEALIGNMENT Does nothing but a trivial alignment</span>
<span class="comment">%   [DISTANCE PATH1 PATH2]=NONEALIGNMENT(X,Y,OPTIONS) produces</span>
<span class="comment">%   a trivial alignment in which warping is a simple line.</span>
path1 = 1:length(x);
path2 = 1:length(y);
distance = sqrt(sum((x - y).^2));
<span class="keyword">end</span>

<span class="keyword">function</span> [distance, path1, path2] = sagaalignment(x,y,options)
<span class="comment">%SAGAALIGNMENT Signal Alignment via Genetic Algorithm</span>
<span class="comment">%   [DISTANCE PATH1 PATH2]=SAGAALIGNMENT(X,Y,OPTIONS) aligns</span>
<span class="comment">%   the objects X and Y using available options OPTIONS and returns</span>
<span class="comment">%   the distance in DISTANCE and warping paths in PATH1 and PATH2.</span>

J = @(s) tscu_saga_cost(x,y,s,options.SAGAw,options.SAGAz);
<span class="keyword">switch</span> options.SAGAOptimizationMethod
    <span class="keyword">case</span> <span class="string">'GA'</span>
        gaoptions = gaoptimset(<span class="string">'Generations'</span>,100,<span class="keyword">...</span>
            <span class="string">'TolFun'</span>, eps, <span class="keyword">...</span>
            <span class="string">'StallGenLimit'</span>,40,<span class="keyword">...</span>
            <span class="string">'Display'</span>,<span class="string">'off'</span>,<span class="keyword">...</span>
            <span class="string">'PopulationSize'</span>,20,<span class="keyword">...</span>
            <span class="string">'PopInitRange'</span>,1*[-1;1]);
        [sbest, distance]=ga(J,options.SAGABaseLength,[],[],[],[],-2,2,[],gaoptions);
	[~,path2] = tscu_saga_warp(y,sbest);
	path1=1:length(x);
    <span class="keyword">case</span> <span class="string">'Simplex'</span>
        [sbest, distance] = fminsearch(J,options.SAGAInitialSolution);
        [~, path2] = tscu_saga_warp(y,sbest);
        path1=1:length(x);
    <span class="keyword">case</span> <span class="string">'GA_MEX'</span>
	[path1, path2, distance]=tscu_saga_register(x,y,options.SAGABaseLength,<span class="keyword">...</span>
    		options.SAGAz,<span class="keyword">...</span>
    		options.SAGAw,<span class="keyword">...</span>
    		options.SAGAs,<span class="keyword">...</span>
    		options.SAGAsbest,<span class="keyword">...</span>
            options.SAGAbmat');
    <span class="keyword">otherwise</span>
        displine(<span class="string">'Warning'</span>,sprintf(<span class="string">'Optimization function "%s" is not defined. Using'</span>,<span class="keyword">...</span>
            options.SAGAOptimizationMethod),<span class="string">'GA'</span>,options);
	[path1, path2, distance]=tscu_saga_register(x,y,options.SAGABaseLength,<span class="keyword">...</span>
    		options.SAGAz,<span class="keyword">...</span>
    		options.SAGAw,<span class="keyword">...</span>
    		options.SAGAs,<span class="keyword">...</span>
    		options.SAGAsbest,<span class="keyword">...</span>
            options.SAGAbmat');
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [distance, path1, path2] = cregalignment(x,y,options)
<span class="comment">%CREGALIGNMENT Curve Registration of Ramsay &amp; Silverman</span>
<span class="comment">%   [DISTANCE PATH1 PATH2]=CREGALIGNMENT(X,Y,OPTIONS) aligns</span>
<span class="comment">%   the objects X and Y using available options OPTIONS and returns</span>
<span class="comment">%   the distance in DISTANCE and warping paths in PATH1 and PATH2.</span>
nx = length(x);
ny = length(y);
nbasis = 10;
norder = 6;
basis = create_bspline_basis([1,nx], nbasis, norder);
xfd = data2fd(x, 1:nx, basis);
yfd = data2fd(y, 1:ny, basis);

nwbasis = 4;
nworder = 3;
wbasis = create_bspline_basis([1,nx], nwbasis, nworder);
Wfd0 = fd(zeros(nwbasis,1), wbasis);

[yfdnew,dummy,warpfd] = registerfd(xfd, yfd, Wfd0);

ynew = eval_fd(yfdnew, 1:ny);
warpvec = eval_mon(1:nx, warpfd);
warpvec = warpvec/max(warpvec);

path1 = 1:nx;
path2 = 1 + warpvec'/max(warpvec)*(nx-1);

distance = sqrt(sum((ynew'-x).^2));
<span class="keyword">end</span>


<span class="keyword">function</span> [distance,path1,path2] = dtwalignment(x,y,options)
<span class="comment">%DTWALIGNMENT Dynamic Time Warping alignment</span>
<span class="comment">%   [DISTANCE PATH1 PATH2]=DTWALIGNMENT(X,Y,OPTIONS) aligns</span>
<span class="comment">%   the objects X and Y using available options OPTIONS and returns</span>
<span class="comment">%   the distance in DISTANCE and warping paths in PATH1 and PATH2.</span>
[distance,path1, path2]=tscu_dtw(x,y,length(x));
path1 = fliplr(path1);
path2 = fliplr(path2);
<span class="keyword">end</span>

<span class="keyword">function</span> [distance, path1, path2] = cdtwalignment(x,y,options)
<span class="comment">%CDTWALIGNMENT Constained Dynamic Time Warping alignment</span>
<span class="comment">%   [DISTANCE PATH1 PATH2]=CDTWALIGNMENT(X,Y,OPTIONS) aligns</span>
<span class="comment">%   the objects X and Y using available options OPTIONS and returns</span>
<span class="comment">%   the distance in DISTANCE and warping paths in PATH1 and PATH2.</span>
[distance, path1, path2]=tscu_dtw(x,y,floor(options.DTWbandwidth*length(x)/100));
path1 = fliplr(path1);
path2 = fliplr(path2);
<span class="keyword">end</span>

<span class="keyword">function</span> perf = performance(truelabels,estimatedlabels)
<span class="comment">%PERFORMANCE Evaluates the performance of a classifier.</span>
<span class="comment">%   P = PERFORMANCE(TRUELABELS,ESTIMATEDLABELS) calculated</span>
<span class="comment">%   performance metrics and store them in the ouput P.</span>
uniqtruelabels = unique(sort(truelabels));
uniqestimatedlabels = unique(sort(estimatedlabels));
n = length(uniqtruelabels);
confmat = zeros(n,n);
<span class="keyword">for</span> i = 1:length(truelabels)
    truelabel = truelabels(i);
    estimatedlabel = estimatedlabels(i);

    ii = find(uniqestimatedlabels == estimatedlabel);
    jj = find(uniqtruelabels == truelabel);
    confmat(ii,jj) = confmat(ii,jj)+1;
<span class="keyword">end</span>

<span class="comment">% sum of row, niplus</span>
niplus  = sum(confmat,2);
njplus  = sum(confmat,1);
nn       = sum(njplus);

<span class="comment">% overall, producer's and user's accuracy</span>
OA      = trace(confmat)/nn;
PA      = diag(confmat)./njplus';
UA      = diag(confmat)./niplus ;

<span class="comment">% proportion of samples</span>
pij     = confmat./nn;
piplus  = sum(pij,2);
pjplus  = sum(pij,1);

po      = trace(pij);
pc      = sum(piplus.*pjplus');
kappa   = (po - pc )/(1-pc);
theta1  = sum(diag(confmat))/nn;
theta2  = sum(niplus.*njplus')/(nn*nn);
theta3  = sum(diag(confmat).*(niplus+njplus'))/(nn*nn);

theta4  = sum(sum(confmat .* (repmat(niplus',size(confmat,1),1) +<span class="keyword">...</span>
    repmat(njplus,size(confmat,1),1)).^2,2))/(nn^3);
varK    = ((theta1*(1-theta1)/(1-theta2)^2) + <span class="keyword">...</span>
    (2*(1-theta1)*(2*theta1*theta2-theta3))/(1-theta2)^3 + <span class="keyword">...</span>
    (((1-theta1)^2)*(theta4-(4*(theta2^2)))) /((1-theta2)^2)) / n;
Z       = kappa/sqrt(varK);

<span class="comment">% Display stuff</span>
confmatdisplay = <span class="string">''</span>;
confmatdisplay = sprintf(<span class="string">'Confusion matrix\n%s      '</span>,confmatdisplay);
<span class="keyword">for</span> i=1:n
    confmatdisplay = sprintf(<span class="string">'%s%5d '</span>,confmatdisplay,uniqtruelabels(i));
<span class="keyword">end</span>
confmatdisplay = sprintf(<span class="string">'%s%5s %5s '</span>,confmatdisplay,<span class="string">'UA'</span>,<span class="string">'TO'</span>);
confmatdisplay = sprintf(<span class="string">'%s\n'</span>,confmatdisplay);
<span class="keyword">for</span> i=1:n
    confmatdisplay=sprintf(<span class="string">'%s%5d '</span>,confmatdisplay,uniqtruelabels(i));
    <span class="keyword">for</span> j=1:n
        confmatdisplay=sprintf(<span class="string">'%s%5d '</span>,confmatdisplay,confmat(i,j));
    <span class="keyword">end</span>
    confmatdisplay=sprintf(<span class="string">'%s%5.3f %5d '</span>,confmatdisplay,UA(i),sum(confmat(i,:)));
    confmatdisplay=sprintf(<span class="string">'%s\n'</span>,confmatdisplay);
<span class="keyword">end</span>
confmatdisplay=sprintf(<span class="string">'%s%5s '</span>,confmatdisplay,<span class="string">'PA'</span>);
<span class="keyword">for</span> j=1:n
    confmatdisplay=sprintf(<span class="string">'%s%5.3f '</span>,confmatdisplay,PA(j));
<span class="keyword">end</span>
confmatdisplay=sprintf(<span class="string">'%s\n'</span>,confmatdisplay);
confmatdisplay=sprintf(<span class="string">'%s%5s '</span>,confmatdisplay,<span class="string">'TO'</span>);
<span class="keyword">for</span> j=1:n
    confmatdisplay=sprintf(<span class="string">'%s%5d '</span>,confmatdisplay,sum(confmat(:,j)));
<span class="keyword">end</span>
confmatdisplay=sprintf(<span class="string">'%s%5s %5d '</span>,confmatdisplay,<span class="string">''</span>,sum(confmat(:)));
confmatdisplay=sprintf(<span class="string">'%s\n'</span>,confmatdisplay);

perf.OA = OA;
perf.PA = PA;
perf.UA = UA;
perf.error = 1-OA;
perf.kappa = kappa;
perf.Z = Z;
perf.confmat = confmat;
perf.confmatdisplay = confmatdisplay;

<span class="keyword">end</span>
</pre><pre class="codeoutput error">Error using tscu (line 113)
Not enough input arguments.
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
function out = tscu(x,y,varargin)
%TSCU Time Series Classification Utility
%   TSCU(X) first divides the set X into training and testing sets
%   randomly, then classifies the time series in the testing set by using
%   the time series in the training set  with default classification
%   method (K-NN) and distance metric (Euclidean). The rows of X
%   corresponds to the time series. The first column defines the labels of
%   the time series.
%
%   TSCU(X,Y) classifies the time series in the testing set Y by using
%   the time series in the training set X with default classification
%   method (K-NN) and distance metric (Euclidean). The rows of both X and Y
%   corresponds to the time series in the training and testing sets,
%   respectively. The first column of both X and Y should be the labels of
%   the time series.
%
%   TSCU(X,Y,'option1',value1,'option2',value2,...) classifies
%   the time series in Y by using training set X by using the options.
%   Available options are:
%
%   'Classifier': The preferrred classification technique
%    'K-NN'   : K Nearest Neighbor
%    'SVM'    : Linear Support Vector Machines
%    default  : 'K-NN'
%
%   'Alignment': Alignment method
%    'NONE'   : no alignment
%    'DTW'    : Dynamic Time Warping
%    'CDTW'   : Constained Time Warping
%    'SAGA'   : Signal Alignment via Genetic Algorithm
%    'CREG'   : Curve Registration of Ramsay & Silverman
%    default  : 'NONE'
%
%   'SVMKernel': Kernel type of SVM classifier
%    'linear'     : Linear
%    'gaussian'   : Gaussian
%    default      : 'linear'
%
%   'LogLevel': Log level
%    'Emergency'  : (level 0)
%    'Alert'      : (level 1)
%    'Critical'   : (level 2)
%    'Error'      : (level 3)
%    'Warning'    : (level 4)
%    'Notice'     : (level 5)
%    'Info'       : (level 6)
%    'Debug'      : (level 7)
%    default      : 'Info'
%
%   'SAGAOptimizationMethod': Optimization technique used in SAGA
%    'GA'         : Genetic Algorithm
%    'GA_MEX'     : A simplified MEX version of Genetic Algorithm
%    'Simplex'    : Nelder-Mead Simplex method (fminsearch of MATLAB)
%    default      : 'GA_MEX'
%
%   'SAGABaseLength': The number of B-spline bases in ODE
%    default      : 8
%
%   'SAGAInitialSolution': Initial solution in SAGA
%    default      : zero vector with length SAGABaseLength.
%
%   'CrossValidation': An integer specifying how many time the
%    cross validation takes place.
%    default      : 0 means don't do cross validation
%
%   'MATLABPool': MATLAB pool used for parallel computing
%    'local' : Set it it 'local' if you want to use the processors
%              available in local PC.
%    default : '' no pool for parallel computing.
%
%   'reportLineWidth': Line width of report lines. Actually it defines
%    the width of the first part of the lines.
%    default : 60
%
%   'trainingRatio': Ratios of training set to the whole set of training
%    and testing. Defined between 0 and 1.
%    default : 0.30
%
%   'DTWbandwidth': It is the width of the Sakoe-Chiba band defined in
%    percentage. Setting it to 100 is the same effect as running DTW.
%    default: 6
%
%   'DisplayInputData': Display both training and testing data
%    'yes'          : plot the input data
%    'no'           : don't display!
%    default : 'no'
%
%   'DisplayAlignment': Display alignment for the specified instances
%    defined as {trnidx, tstidx}
%    default : {[],[]} (means no alignment is displayed)
%    example : tscu(trn,tst,'DisplayAlignment',{[1 3],[1]}) will display the
%    alignment of test sample 1 to the training samples 1 and 3, so
%    two alignments will be displayed.
%
%    The figures will be saved in PDF on the current directory.
%
%   'DumpDistanceMatrix': Dump the distance matrix ta a txt file.
%    'yes' : dump it
%    'no'  : don't!
%    default : 'no'
%
%   Z = TSCU(...) returns output values in the structure Z.
%

% I'm adding this small library of Oliver Woodford to produce PDFs
% ready for publication It's license allows me to include it.
% See lib/export_fig/license.txt
addpath('lib/export_fig');
addpath('lib/creg');

options = getDefaultOptions;
if nargin == 0
    error('tscu:noinput','Not enough input arguments.');
elseif nargin == 1
    [x,y]=divideset(x,options);
    displine('Info','Size of input set',sprintf('%d',size(x,1)),options);
    displine('Info','Dividing input into trn/tst','done',options);
elseif nargin == 2,
    if size(x,2) ~= size(y,2)
        error('tscu:invalidlength',...
            'Length of time series in training and testing sets should be equal');
    end
end

optarglength = size(varargin,2);
if mod(optarglength,2) ~= 0
    error('tscu:argerror','The number of optional parameters should be even');
else
    for i=1:2:optarglength
        switch varargin{i}
            case 'Classifier'
                options.classifier = varargin{i+1};
            case 'Alignment'
                options.alignment = varargin{i+1};
            case 'SVMKernel'
                options.svmkernel = varargin{i+1};
            case 'DTWbandwidth'
                options.DTWbandwidth = varargin{i+1};
            case 'LogLevel'
                options.loglevel = varargin{i+1};
            case 'MATLABPool'
                options.MATLABPool = varargin{i+1};
            case 'SAGAOptimizationMethod'
                options.SAGAOptimizationMethod = varargin{i+1};
            case 'SAGABaseLength'
                options.SAGABaseLength = varargin{i+1};
            case 'SAGAInitialSolution'
                options.SAGAInitialSolution = varargin{i+1};
            case 'CrossValidation'
                options.CrossValidation = varargin{i+1};
            case 'DisplayInputData'
                options.DisplayInputData = varargin{i+1};
            case 'DisplayAlignment'
                options.DisplayAlignment = varargin{i+1};
            case 'DumpDistanceMatrix'
                options.DumpDistanceMatrix = varargin{i+1};
        end
    end
end

% Opening MATLAB pool
if ~isempty(options.MATLABPool)
    displine('Info','Setting parallel processing','',options);
    matlabpool('open',options.MATLABPool);
end

if options.SAGABaseLength ~= length(options.SAGAInitialSolution)
    displine('Warning','Size of initial solution should be',...
        sprintf('%d',length(options.SAGABaseLength)),options);
end

% Check the optimization method
switch options.SAGAOptimizationMethod
    case 'GA'
    case 'Simplex'
    case 'GA_MEX'
    otherwise
        displine('Warning',sprintf('The method "%s" is not recognized',...
            options.SAGAOptimizationMethod),'GA_MEX will be used',options);
        options.SAGAOptimizationMethod = 'GA_MEX';
end

switch options.alignment
    case 'NONE'
        options.alignmentfunction = @nonealignment;
    case 'DTW'
        options.alignmentfunction = @dtwalignment;
    case 'CDTW'
        options.alignmentfunction = @cdtwalignment;
    case 'SAGA'
        options.alignmentfunction = @sagaalignment;
        n = size(x,2)-1;
        k = options.SAGABaseLength;
        options.SAGAz = zeros(1,n);
        options.SAGAw = zeros(1,n);
        options.SAGAs = zeros(1,k);
        options.SAGAsbest = zeros(1,k);
        u = zeros(n,k);
        nk = round(n/k);
        lastpiece = n-nk*k;
        for i=0:k-2
            u(nk*i+1:nk*i+nk,i+1)=1;
        end
        u(n-lastpiece-1:n,k)=1;
        integration    = @(s) cumsum(s)/(size(s,1)-1);
        options.SAGAbmat = integration(integration(u));        
    case 'CREG'
        options.alignmentfunction = @cregalignment;
    otherwise
        options.alignmentfunction = @nonealignment;
end

% Display some debug
displine('Info','Size of training set',sprintf('%d',size(x,1)),options);
displine('Info','Size of testing set',sprintf('%d',size(y,1)),options);
displine('Info','Time series length',sprintf('%d',size(x,2)-1),options);

displine('Info','Classification method',options.classifier,options);
if strcmp(options.classifier,'SVM')
    displine('Info','SVM kernel type',options.svmkernel,options);
end
displine('Info','Alignment method',options.alignment,options);
displine('Info','Displaying input data',options.DisplayInputData,options);

if options.CrossValidation < 1
    displine('Info','No cross validation is chosen',...
        sprintf('%d',options.CrossValidation),options);
else
    displine('Info','Cross validation is not implemented',...
        sprintf('%d',options.CrossValidation),options);
end
if strcmp(options.alignment,'SAGA')
    displine('Info','SAGA number of spline bases',...
        sprintf('%d',options.SAGABaseLength),options);
    displine('Info','SAGA optimization method',...
        options.SAGAOptimizationMethod,options);
    displine('Info','SAGA initial solution',...
        sprintf('%5.2f ',options.SAGAInitialSolution),options);
end
if strcmp(options.alignment,'CDTW')
    displine('Info','DTW band width (%)',...
        sprintf('%5.2f',options.DTWbandwidth),options);
end
if ~isempty(options.MATLABPool)
    displine('Info','MATLAB Pool',options.MATLABPool,options);
end

if numel(options.DisplayAlignment{1}) > 0 && numel(options.DisplayAlignment{2}) > 0
    displine('Info','Displaying alignments (trn)',...
        sprintf('%d',options.DisplayAlignment{1}),options);
    displine('Info','Displaying alignments (tst)',...
        sprintf('%d',options.DisplayAlignment{2}),options);
else
    displine('Info','Displaying alignments','none',options);
end
displine('Info','Dumping distance matrix',options.DumpDistanceMatrix,options);


% Displaying Input Data
if strcmp(options.DisplayInputData,'yes')
    displayInputData(x,y,options);
end
displayClassInfo(x,y,options);


% Classification
tic
switch options.classifier
    case 'K-NN'
        labels = nnclassifier(x,y,options);
    case 'SVM'
        labels = svmclassifier(x,y,options);
    otherwise
        labels = nnclassifier(x,y,options);
end
classification_time = toc;

% Performance
perf = performance(y(:,1),labels);
displine('Info','Overall Accuracy',sprintf('%-8.3f',perf.OA),options);
displine('Info','Overall Error',sprintf('%-8.3f',perf.error),options);
displine('Info','Producer Accuracy',sprintf('%-8.3f',perf.PA),options);
displine('Info','User Accuracy',sprintf('%-8.3f',perf.UA),options);
displine('Info','Kappa',sprintf('%-8.3f',perf.kappa),options);
displine('Info','Z-value',sprintf('%-8.3f',perf.Z),options);
displine('Info','Confusion matrix',sprintf('\n%s',perf.confmatdisplay),options);
displine('Info','Classification time (sec)',...
    sprintf('%-8.2f',classification_time),options);

% Closing the MATLAB pool if paralel process
if ~isempty(options.MATLABPool)
    displine('Info','Setting parallel processing','',options);
    matlabpool close
end

% Returning output
out.labels              = labels;
out.truelabels          = y(:,1);
out.classification_time = classification_time;
out.perf                = perf;
displine('Info','The end of TSCU','FINISHED',options);
end

function displayClassInfo(x,y,options)
% Display class information

uniquelabels=unique([x(:,1);y(:,1)]);
% For each class
for i=1:length(uniquelabels)
    trnidx = uniquelabels(i)==x(:,1);
    tstidx = uniquelabels(i)==y(:,1);
    displine('Info','Class information',...
        sprintf('%d [TRN:%3d TST:%3d]',uniquelabels(i),sum(trnidx),sum(tstidx)),options);
    
end
end

function displayInputData(x,y,options)
% Display training and testing sets.

uniquelabels=unique([x(:,1);y(:,1)]);
% For each class
for i=1:length(uniquelabels)
    trnidx = uniquelabels(i)==x(:,1);
    tstidx = uniquelabels(i)==y(:,1);
    
    
    figure
    subplot(211);
    plot(x(trnidx,2:end)','k');
    title(sprintf('%d time series in training set of class label %d',...
        sum(trnidx),uniquelabels(i)));
    subplot(212);
    plot(y(tstidx,2:end)','k');
    title(sprintf('%d time series in testing set of class label %d',...
        sum(tstidx),uniquelabels(i)));
end
end

function options = getDefaultOptions(varargin)
% Please see help tscu for available options.

options.classifier               = 'K-NN';
options.alignment                = 'NONE';
options.loglevel                 = 'Info';
options.svmkernel                = 'linear';
options.reportLineWidth          = 40;
options.trainingRatio            = 0.3;
options.DTWbandwidth             = 6;
options.MATLABPool               = '';
options.SAGAOptimizationMethod  = 'GA_MEX';
options.SAGABaseLength          = 8;
options.SAGAInitialSolution     = zeros(1,options.SAGABaseLength);
options.DisplayInputData        = 'no';
options.CrossValidation         = 0;
options.DisplayAlignment        = {[],[]};
options.DumpDistanceMatrix      = 'no';
options.alignmentfunction       = @nonealignment;
if nargin > 0 && mod(nargin,2) ~= 0
    error('tscu:invalidoption','The number of input variables must be even');
end
end

function displine(l,k,v,o)
%DISPLINE Display a report line
%   DISPLINE(L,K,V,O) display the string K with value V by using
%   the parameters in O if current loglevel is less than or equal to
%   logvel K. For example, DISPLINE('Info','Length',12,options)
%   will display
%   Length.......................: 12
%   if the current log level option is 'Info' or 'Debug'.
%   See options.loglevel setting.

if getloglevelindex(l) <= getloglevelindex(o.loglevel)
    out=sprintf('%s',k);
    for i=length(k):o.reportLineWidth
        out=sprintf('%s.',out);
    end
    out=sprintf('%s: %s',out,v);
    fprintf('%s\n',out)
end
end

function i = getloglevelindex(l)
%GETLOGLEVELINDEX  Conversion of log level string.
%   GETLOGLEVELINDEX(L) gets the corresponding integer for a given
%   log level L.
switch l
    case 'Emergency'
        i = 0;
    case 'Alert'
        i = 1;
    case 'Critical'
        i = 2;
    case 'Error'
        i = 3;
    case 'Warning'
        i = 4;
    case 'Notice'
        i = 5;
    case 'Info'
        i = 6;
    case 'Debug'
        i = 7;
    otherwise
        i = 6;
end
end
function [trn,tst]=divideset(x,options)
%DIVIDESET Divides a set of time series into two parts.
%   DIVIDESET(X,OPTIONS) divides the dataset X into training (X) and testing
%   sets (Y) by using the ratios OPTIONS.trainingRatio.
%
%
m=size(x,1);
labels = x(:,1);

% index of which objects will be reserved for training.
trnidx = zeros(m,1);
% If a label is not an integer, exit with error.
floatlabels=find(abs(round(labels)-labels)>eps);
if numel(floatlabels) > 0
    error('tscu:floatinglabels',...
        'Some labels are not integer. Example: label of object [%d] is %f',floatlabels(1),x(floatlabels(1),1));
end
uniquelabels = unique(labels);
for i=1:length(uniquelabels)
    label=uniquelabels(i);
    labelidx = find(label==labels);
    
    trnlength = round(length(labelidx)*options.trainingRatio);
    
    if trnlength < 1
        warning('tscu:divideset','There is no object left to training set for label %d',label);
        trnlength = 0;
    end
    trnidx(labelidx(1:trnlength))=1;
end
trn = x(trnidx==1,:);
tst = x(trnidx==0,:);
end

function labels = nnclassifier(x,y,options)
%NNCLASSIFIER Nearest Neighbor Classification
%   LABELS = NNCLASSIFIER(X,Y,OPTIONS) classifies the time series in
%   testing set Y by using the time series in training set X with the
%   nearest neighbor algorithm resulting estimated labels LABELS.
xlabels = x(:,1);
ylabels = y(:,1);
n = size(x,1); % training
m = size(y,1); % testing
[yIdx,xIdx] = meshgrid(1:m,1:n);
alldistances = zeros(1,n*m);

Alignment = options.alignment;
DisplayAlignmentMat = zeros(n,m);
DisplayAlignmentMat(options.DisplayAlignment{1},options.DisplayAlignment{2})=1;

% It may seem awkward not to use two inner loops for a simple
% K-NN classifier. The reason is that I should use just one loop
% to easily distribute the job.
for i = 1 : n*m
    yObject = y(yIdx(i),2:end);
    xObject = x(xIdx(i),2:end);
    path1 = 1:numel(xObject);
    path2 = 1:numel(yObject);
    switch Alignment
        case 'NONE'
            [alldistances(i), path1, path2] = nonealignment(xObject,yObject,options);
        case 'DTW'
            [alldistances(i), path1, path2] = dtwalignment(xObject,yObject,options);
        case 'CDTW'
            [alldistances(i), path1, path2] = cdtwalignment(xObject,yObject,options);
        case 'SAGA'
            [alldistances(i), path1, path2] = sagaalignment(xObject,yObject,options);
        case 'CREG'
            [alldistances(i), path1, path2] = cregalignment(xObject,yObject,options);
        otherwise
            [alldistances(i), path1, path2] = nonealignment(xObject,yObject,options);
    end
    displine('Debug',sprintf('[%5d of %5d] dist(%4d,%4d)',i,n*m,yIdx(i),xIdx(i)),...
        sprintf('%f',alldistances(i)),options);
    if DisplayAlignmentMat(i)
        displayAlignment(x,y,xIdx(i),yIdx(i),path1,path2,Alignment,options)
    end
end
distancematrix = reshape(alldistances,n,m);
[~,mindistanceIdx]=min(distancematrix);
labels = xlabels(mindistanceIdx);
displine('Debug','index of testing objects',sprintf('%3d ',1:m),options);
displine('Debug','labels of testing objects (True)',sprintf('%3d ',ylabels),options);
displine('Debug','labels of testing objects (Estimated)',sprintf('%3d ',labels),options);
displine('Debug','closest training objects',sprintf('%3d ',mindistanceIdx),options);

if strcmp(options.DumpDistanceMatrix,'yes')
    save(sprintf('tscu_distancematrix_%s.txt',Alignment),'distancematrix','-ascii');
end

end

function labels = svmclassifier(x,y,options)
%SVMCLASSIFIER Support Vector Machine Classification
%   LABELS = SVMCLASSIFIER(X,Y,OPTIONS)

classlabels=unique(sort(x(:,1)));
m=length(classlabels);
tstlabels=zeros(size(y,1),(m-1)*m/2);

opt=optimset('maxiter',500,'largescale','off','display','off');
% One against one approach
k=1;
for i=1:m-1
    for j=i+1:m
        % Training
        class_one=x(x(:,1)==classlabels(i),2:end);
        class_two=x(x(:,1)==classlabels(j),2:end);
        objects=[class_one;class_two];
        truelabels=[-ones(size(class_one,1),1);ones(size(class_two,1),1)];
        displine('Debug','SVM one-against-one',...
            sprintf('class %2d .vs. class %2d',classlabels(i),classlabels(j)),options);
        nx=size(objects,1);
        xlen=size(objects,2);
        R=zeros(nx,nx);
        e=1e-6;
        C=10;                               %Functional Trade-off

        
        switch options.svmkernel
            case 'linear'
                if strcmp(options.alignment,'NONE')
                    R=objects*objects';
                else
                    for ii=1:nx-1
                        for jj=ii+1:nx
                            [distance, path1, path2]=options.alignmentfunction(objects(ii,:),objects(jj,:),options);
                            xAligned = interp1(1:xlen,objects(ii,:),path1);
                            yAligned = interp1(1:xlen,objects(jj,:),path2);
                            displine('Debug','Aligning',sprintf('%5d .vs. %5d',ii,jj),options);
                            R(ii,jj)=xAligned*yAligned';
                            R(jj,ii)=R(ii,jj);
                        end
                    end
                    for ii=1:nx
                        R(ii,ii)=objects(ii,:)*objects(ii,:)';
                    end
                end
            case 'gaussian'
                sigma=1;       % Parameter of the kernel
                D=buffer(sum([kron(objects,ones(nx,1))...
                  - kron(ones(1,nx),objects')'].^2,2),nx,0);
                R=exp(-D/(2*sigma)); % Kernel Matrix               
        end      
        
        Y=diag(truelabels);
        H=Y*R*Y+1e-6*eye(length(truelabels));         %Matrix H regularized
        f=-ones(size(truelabels)); a=truelabels'; K=0;
        Kl=zeros(size(truelabels));
        Ku=C*ones(size(truelabels));
        alpha=quadprog(H,f,[],[],a,K,Kl,Ku,[],opt); %Solver
        
        switch options.svmkernel
            case 'linear'
                w=objects'*(alpha.*truelabels);               
                %ind=find(alpha>e & alpha<=C-e);
                ind=find(alpha<C);
                b=mean(truelabels(ind) - objects(ind,:)*w);
                % Testing
                tstvalues=y(:,2:end)*w+b;
                
                %figure
                %subplot(121)
                %plot(alpha,'.');
                %title(sprintf('%d %d',i,j));
                %subplot(122);
                %plot(eig(H),'.');
                

            case 'gaussian'
                ind=find(alpha>e);
                x_sv=objects(ind,:);    % Extraction of the
                                         % support vectors
                N_SV=length(ind); 
                ind=find(alpha>e & alpha<C-e);
                N_margin=length(ind);
                D=buffer(sum([kron(x_sv,ones(N_margin,1))...
                 - kron(ones(1,N_SV),objects(ind,:)')'].^2,2),N_margin,0);
                R_margin=exp(-D/(2*sigma));
                y_margin=R_margin*(truelabels(ind).*alpha(ind));
                b=mean(truelabels(ind) - y_margin); 
                
                N_test=size(y,1);                
                D=buffer(sum([kron(x_sv,ones(N_test,1))...
                 - kron(ones(1,N_SV),y(:,2:end)')'].^2,2),N_test,0);
                R_test=exp(-D/(2*sigma));
                tstvalues=R_test*(truelabels(ind).*alpha(ind))+b;
        end
        tstlabels(tstvalues< 0,k)=classlabels(i);
        tstlabels(tstvalues>=0,k)=classlabels(j);
        k = k + 1;
    end
end
labels=mode(tstlabels,2);

displine('Info','index of testing objects',sprintf('%3d ',1:size(y,1)),options);
displine('Info','labels of testing objects (True)',sprintf('%3d ',y(:,1)),options);
displine('Info','labels of testing objects (Estimated)',sprintf('%3d ',labels),options);
%displine('Info','closest training objects',sprintf('%3d ',mindistanceIdx),options);

end

function  displayAlignment(x,y,xIdx,yIdx,path1,path2,Alignment,options)
%DISPLAYALIGNMENT Displays the aligned time series
%   DISPLAYALIGNMENT(x,y,xIdx,yIdx,path1,path2,Alignment,options) will
%   display the alignment between the time series x(xIdx,2:end))
%   and y(yIdx,2:end)) by using the determined warpings path1 and path2
%   found by the alignment method Alignment.
xObject = x(xIdx,2:end);
yObject = y(yIdx,2:end);
xAligned = interp1(1:length(xObject),xObject,path1);
yAligned = interp1(1:length(yObject),yObject,path2);

nx = numel(xObject);
xmin = min(xObject);
xmax = max(xObject);

ny = numel(yObject);
ymin = min(yObject);
ymax = max(yObject);

dx = 10;
if nx < 30
    dx = nx;
end
xgrid=round(linspace(1,nx,dx));
ygrid=round(linspace(1,ny,dx));

relErrBefore = norm(xObject - yObject)/norm(xObject);
relErrAfter  = norm(xAligned - yAligned)/norm(xAligned);

figure('Visible','on');
plot(xObject,'b');
hold on;
plot(yObject,'r');
legend('Training','Testing');
title(sprintf('Originals Distance: %8.5f',relErrBefore));
xlim([1 max([nx ny])]);
%export_fig('-pdf','-transparent',...
%    sprintf('tscu_alignment_%03d_%03d_%s_before.pdf',xIdx,yIdx,Alignment));

figure('Visible','on');
plot(xAligned,'b');
hold on;
plot(yAligned,'r');
legend('Training','Testing');
title(sprintf('Alignment (%s) Distance: %8.5f',Alignment,relErrAfter));
xlim([1 length(xAligned)]);
%export_fig('-pdf','-transparent',...
%    sprintf('tscu_alignment_%03d_%03d_%s_after.pdf',xIdx,yIdx,Alignment));

% warping is scaled to [0 1]
figure('Visible','on');
%plot((path1-1)/(length(path1)-1),(path2-1)/(length(path2)-1),'b');
plot(path1,path2,'b');
hold on
plot(nx*0.20*((xObject-xmin)/(xmax-xmin)-1),'r');
plot(ny*0.20*((yObject-ymin)/(ymax-ymin)-1),1:ny,'r');
set(gca,'XTick',[],'YTick',[])
box on
plot(xgrid,meshgrid(xgrid,ygrid),'k:');
plot(meshgrid(xgrid,ygrid),ygrid,'k:');

if strcmp(Alignment,'CDTW')
    band=floor(options.DTWbandwidth*nx/100);
    plot([1 1    nx-band nx],[1 band ny      ny],'k');
    plot([1 band nx      nx],[1 1    ny-band ny],'k');
end

axis equal
xlim([-nx*0.20 nx+1]);
ylim([-ny*0.20 ny+1]);
%export_fig('-pdf','-transparent',...
%    sprintf('tscu_alignment_%03d_%03d_%s_warping.pdf',xIdx,yIdx,Alignment));

figure('Visible','on');
for i=round(linspace(1,length(path1),50))
    plot([path1(i) path2(i)], ...
        [interp1(1:nx,xObject,path1(i)) interp1(1:ny,yObject,path2(i))+2*xmax],'k');
    hold on
end
plot(xObject,'b');
plot(2*xmax+yObject','b');
xlim([0 nx]);
set(gca,'XTick',[],'YTick',[])
box on
%export_fig('-pdf','-transparent',...
%    sprintf('tscu_alignment_%03d_%03d_%s_warpingLines.pdf',xIdx,yIdx,Alignment));
end

function [distance, path1, path2] = nonealignment(x,y,options)
%NONEALIGNMENT Does nothing but a trivial alignment
%   [DISTANCE PATH1 PATH2]=NONEALIGNMENT(X,Y,OPTIONS) produces
%   a trivial alignment in which warping is a simple line.
path1 = 1:length(x);
path2 = 1:length(y);
distance = sqrt(sum((x - y).^2));
end

function [distance, path1, path2] = sagaalignment(x,y,options)
%SAGAALIGNMENT Signal Alignment via Genetic Algorithm
%   [DISTANCE PATH1 PATH2]=SAGAALIGNMENT(X,Y,OPTIONS) aligns
%   the objects X and Y using available options OPTIONS and returns
%   the distance in DISTANCE and warping paths in PATH1 and PATH2.

J = @(s) tscu_saga_cost(x,y,s,options.SAGAw,options.SAGAz);
switch options.SAGAOptimizationMethod
    case 'GA'
        gaoptions = gaoptimset('Generations',100,...
            'TolFun', eps, ...
            'StallGenLimit',40,...
            'Display','off',...
            'PopulationSize',20,...
            'PopInitRange',1*[-1;1]);
        [sbest, distance]=ga(J,options.SAGABaseLength,[],[],[],[],-2,2,[],gaoptions);
	[~,path2] = tscu_saga_warp(y,sbest);
	path1=1:length(x);
    case 'Simplex'
        [sbest, distance] = fminsearch(J,options.SAGAInitialSolution);
        [~, path2] = tscu_saga_warp(y,sbest);
        path1=1:length(x);
    case 'GA_MEX'
	[path1, path2, distance]=tscu_saga_register(x,y,options.SAGABaseLength,...
    		options.SAGAz,...
    		options.SAGAw,...
    		options.SAGAs,...
    		options.SAGAsbest,...
            options.SAGAbmat');
    otherwise
        displine('Warning',sprintf('Optimization function "%s" is not defined. Using',...
            options.SAGAOptimizationMethod),'GA',options);
	[path1, path2, distance]=tscu_saga_register(x,y,options.SAGABaseLength,...
    		options.SAGAz,...
    		options.SAGAw,...
    		options.SAGAs,...
    		options.SAGAsbest,...
            options.SAGAbmat');
end
end

function [distance, path1, path2] = cregalignment(x,y,options)
%CREGALIGNMENT Curve Registration of Ramsay & Silverman
%   [DISTANCE PATH1 PATH2]=CREGALIGNMENT(X,Y,OPTIONS) aligns
%   the objects X and Y using available options OPTIONS and returns
%   the distance in DISTANCE and warping paths in PATH1 and PATH2.
nx = length(x);
ny = length(y);
nbasis = 10;
norder = 6;
basis = create_bspline_basis([1,nx], nbasis, norder);
xfd = data2fd(x, 1:nx, basis);
yfd = data2fd(y, 1:ny, basis);

nwbasis = 4;
nworder = 3;
wbasis = create_bspline_basis([1,nx], nwbasis, nworder);
Wfd0 = fd(zeros(nwbasis,1), wbasis);

[yfdnew,dummy,warpfd] = registerfd(xfd, yfd, Wfd0);

ynew = eval_fd(yfdnew, 1:ny);
warpvec = eval_mon(1:nx, warpfd);
warpvec = warpvec/max(warpvec);

path1 = 1:nx;
path2 = 1 + warpvec'/max(warpvec)*(nx-1);

distance = sqrt(sum((ynew'-x).^2));
end


function [distance,path1,path2] = dtwalignment(x,y,options)
%DTWALIGNMENT Dynamic Time Warping alignment
%   [DISTANCE PATH1 PATH2]=DTWALIGNMENT(X,Y,OPTIONS) aligns
%   the objects X and Y using available options OPTIONS and returns
%   the distance in DISTANCE and warping paths in PATH1 and PATH2.
[distance,path1, path2]=tscu_dtw(x,y,length(x));
path1 = fliplr(path1);
path2 = fliplr(path2);
end

function [distance, path1, path2] = cdtwalignment(x,y,options)
%CDTWALIGNMENT Constained Dynamic Time Warping alignment
%   [DISTANCE PATH1 PATH2]=CDTWALIGNMENT(X,Y,OPTIONS) aligns
%   the objects X and Y using available options OPTIONS and returns
%   the distance in DISTANCE and warping paths in PATH1 and PATH2.
[distance, path1, path2]=tscu_dtw(x,y,floor(options.DTWbandwidth*length(x)/100));
path1 = fliplr(path1);
path2 = fliplr(path2);
end

function perf = performance(truelabels,estimatedlabels)
%PERFORMANCE Evaluates the performance of a classifier.
%   P = PERFORMANCE(TRUELABELS,ESTIMATEDLABELS) calculated
%   performance metrics and store them in the ouput P.
uniqtruelabels = unique(sort(truelabels));
uniqestimatedlabels = unique(sort(estimatedlabels));
n = length(uniqtruelabels);
confmat = zeros(n,n);
for i = 1:length(truelabels)
    truelabel = truelabels(i);
    estimatedlabel = estimatedlabels(i);
    
    ii = find(uniqestimatedlabels == estimatedlabel);
    jj = find(uniqtruelabels == truelabel);
    confmat(ii,jj) = confmat(ii,jj)+1;
end

% sum of row, niplus
niplus  = sum(confmat,2);
njplus  = sum(confmat,1);
nn       = sum(njplus);

% overall, producer's and user's accuracy
OA      = trace(confmat)/nn;
PA      = diag(confmat)./njplus';
UA      = diag(confmat)./niplus ;

% proportion of samples
pij     = confmat./nn;
piplus  = sum(pij,2);
pjplus  = sum(pij,1);

po      = trace(pij);
pc      = sum(piplus.*pjplus');
kappa   = (po - pc )/(1-pc);
theta1  = sum(diag(confmat))/nn;
theta2  = sum(niplus.*njplus')/(nn*nn);
theta3  = sum(diag(confmat).*(niplus+njplus'))/(nn*nn);

theta4  = sum(sum(confmat .* (repmat(niplus',size(confmat,1),1) +...
    repmat(njplus,size(confmat,1),1)).^2,2))/(nn^3);
varK    = ((theta1*(1-theta1)/(1-theta2)^2) + ...
    (2*(1-theta1)*(2*theta1*theta2-theta3))/(1-theta2)^3 + ...
    (((1-theta1)^2)*(theta4-(4*(theta2^2)))) /((1-theta2)^2)) / n;
Z       = kappa/sqrt(varK);

% Display stuff
confmatdisplay = '';
confmatdisplay = sprintf('Confusion matrix\n%s      ',confmatdisplay);
for i=1:n
    confmatdisplay = sprintf('%s%5d ',confmatdisplay,uniqtruelabels(i));
end
confmatdisplay = sprintf('%s%5s %5s ',confmatdisplay,'UA','TO');
confmatdisplay = sprintf('%s\n',confmatdisplay);
for i=1:n
    confmatdisplay=sprintf('%s%5d ',confmatdisplay,uniqtruelabels(i));
    for j=1:n
        confmatdisplay=sprintf('%s%5d ',confmatdisplay,confmat(i,j));
    end
    confmatdisplay=sprintf('%s%5.3f %5d ',confmatdisplay,UA(i),sum(confmat(i,:)));
    confmatdisplay=sprintf('%s\n',confmatdisplay);
end
confmatdisplay=sprintf('%s%5s ',confmatdisplay,'PA');
for j=1:n
    confmatdisplay=sprintf('%s%5.3f ',confmatdisplay,PA(j));
end
confmatdisplay=sprintf('%s\n',confmatdisplay);
confmatdisplay=sprintf('%s%5s ',confmatdisplay,'TO');
for j=1:n
    confmatdisplay=sprintf('%s%5d ',confmatdisplay,sum(confmat(:,j)));
end
confmatdisplay=sprintf('%s%5s %5d ',confmatdisplay,'',sum(confmat(:)));
confmatdisplay=sprintf('%s\n',confmatdisplay);

perf.OA = OA;
perf.PA = PA;
perf.UA = UA;
perf.error = 1-OA;
perf.kappa = kappa;
perf.Z = Z;
perf.confmat = confmat;
perf.confmatdisplay = confmatdisplay;

end

##### SOURCE END #####
--></body></html>